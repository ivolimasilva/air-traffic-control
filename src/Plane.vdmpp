class Plane

	types
		public Direction = <N>|<NE>|<E>|<SE>|<S>|<SW>|<W>|<NW>|<X>;
		public Status = <air>|<landing>|<landed>;
		public Position ::
			x : nat
			y : nat;
		public Directions ::
			x : real
			y : real;

	values
	-- TODO Define values here

	instance variables
		private speed : int;
		private pos : Position;
		private dir : Directions;
		private status : Status;
		private dest : seq of Position := [];

	operations

		-- Construtor of the plane class
		public Plane : int * nat * nat * Status ==> Plane
			Plane(initial_speed, pos_x, pos_y, stat) == (
				speed := initial_speed;
				pos := mk_Position(pos_x, pos_y);
				-- If the dest equals the pos then it means the plane will move only due to direction and not to a specifc goal
				-- dest := dest ^ [mk_Position(pos_x, pos_y)];
				dir := mk_Directions(0, 0);
				status := stat;
			);

		-- Operation to set current speed of the plane
		public setSpeed : int ==> ()
			setSpeed(new_speed) == (
				speed := new_speed;
			);

		-- Operation to get current speed of the plane
		public getSpeed : () ==> int
			getSpeed() == (
				return speed;
			);

		-- Operation to set current position of the plane
		public setPosition : nat * nat ==> ()
			setPosition(initial_x, initial_y) == (
				pos := mk_Position(initial_x, initial_y);
			);
		-- pre: position must be inside map limits

		-- Operation to get current position of the plane
		public getPosition : () ==> Position
			getPosition() == (
				return pos;
			);

		-- Operation to set current directions of the plane
		public setDirections : real * real ==> ()
			setDirections(dir_x, dir_y) == (
				dest := [];
				dir := mk_Directions(dir_x, dir_y);
			);
			

		-- Operation to get current directions of the plane
		public getDirections : () ==> Directions
			getDirections() == (
				return dir;
			);

		-- Operation to get current direction of the plane
		public getDirection : () ==> Direction
			getDirection() == (
				return calcDirSymbol(dir.x, dir.y);
			);

		-- Operation to set current status of the plane
		public setStatus : Status ==> ()
			setStatus(stat) == (
				status := stat;
			);

		-- Operation to get current status of the plane
		public getStatus : () ==> Status
			getStatus() == (
				return status;
			);

		-- Operation to set a destination to the plane
		public setDestination : nat * nat ==> ()
			setDestination(pos_x, pos_y) == (
				-- update destination
				dest := [];
				dest := dest ^ [mk_Position(pos_x, pos_y)];
				-- update direction
				dir.x := pos_x - pos.x;
				dir.y := pos_y - pos.y;
				
				if (dir <> mk_Directions(0, 0))
				then (
					-- unitary direction
					dir.x := floor dir.x / MATH`sqrt(dir.x * dir.x + dir.y * dir.y);
					dir.y := floor dir.y / MATH`sqrt(dir.x * dir.x + dir.y * dir.y);
				)
			);
		-- pre: destination must be inside map limits

		-- Operation to add a destination to the plane
		public addDestination : nat * nat ==> ()
			addDestination(pos_x, pos_y) == (
				dest := dest ^ [mk_Position(pos_x, pos_y)];
			);

		-- Operation to get a destination to the plane
		public getDestination : () ==> seq of Position
			getDestination() == (
				return dest;
			);

		-- Operation to get the plane to move for this round
		public move : () ==> Position
			move() == (

				-- check if plane has any more destinations
				if (dest = [])
				then
					return pos;

				-- check if plane reached destination
				if (pos.x = (hd dest).x and pos.y = (hd dest).y)
				then (
					dest := tl dest;
					dir := mk_Directions(0, 0);

					-- check if plane has any more destinations
					if (dest = [])
					then
						return pos;
				);

				-- update direction
				dir.x := (hd dest).x - pos.x;
				dir.y := (hd dest).y - pos.y;

				-- print directions
				IO`print("Directions: (");
				IO`print(dir.x);
				IO`print(", ");
				IO`print(dir.y);
				IO`print(")\n");

				-- unit direction
				dir.x := floor (dir.x / MATH`sqrt(dir.x * dir.x));
				dir.y := floor (dir.y / MATH`sqrt(dir.y * dir.y));

				-- print directions
				IO`print("Unit: (");
				IO`print(dir.x);
				IO`print(", ");
				IO`print(dir.y);
				IO`print(")\n");

				-- update position
				pos.x := floor (pos.x + (dir.x * speed));
				pos.y := floor (pos.y + (dir.y * speed));

				-- return the new position
				return pos;

			);
		-- pre: plane must have at least one destination
		-- post: position must be inside map limits

	functions

		-- Function to return the symbol of a given direction
		public calcDirSymbol : real * real -> Direction
			calcDirSymbol(dir_x, dir_y) == (
				if (MATH`cos(dir_x / dir_y) = 0 and MATH`sin(dir_x / dir_y) = 1)
					then <N>
				else if (MATH`cos(dir_x / dir_y) = 0 and MATH`sin(dir_x / dir_y) = -1)
					then <S>
				else if (MATH`cos(dir_x / dir_y) = 1 and MATH`sin(dir_x / dir_y) = 0)
					then <E>
				else if (MATH`cos(dir_x / dir_y) = -1 and MATH`sin(dir_x / dir_y) = 0)
					then <W>
				else if (MATH`cos(dir_x / dir_y) > 0 and MATH`cos(dir_x / dir_y) < 1 and MATH`sin(dir_x / dir_y) > 0 and MATH`sin(dir_x / dir_y) < 1)
					then <SW>
				else if (MATH`cos(dir_x / dir_y) > -1 and MATH`cos(dir_x / dir_y) < 0 and MATH`sin(dir_x / dir_y) > 0 and MATH`sin(dir_x / dir_y) < 1)
					then <SE>
				else if (MATH`cos(dir_x / dir_y) > -1 and MATH`cos(dir_x / dir_y) < 0 and MATH`sin(dir_x / dir_y) > -1 and MATH`sin(dir_x / dir_y) < 0)
					then <NE>
				else if (MATH`cos(dir_x / dir_y) > 0 and MATH`cos(dir_x / dir_y) < 1 and MATH`sin(dir_x / dir_y) > -1 and MATH`sin(dir_x / dir_y) < 0)
					then <NW>
				else <X>
			);
			-- Pre-condition: dir_x and dir_y can't be zero at same time
			-- pre (dir_x <> 0 and dir_y <> 0);
			-- Post-condition: dir.symbol can't be <X>
			-- post (dir.symbol <> <X>);

	traces
	-- TODO Define Combinatorial Test Traces here

end Plane