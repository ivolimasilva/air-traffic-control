class Plane

	types
		public Direction = <N>|<NE>|<E>|<SE>|<S>|<SW>|<W>|<NW>|<X>;
		public Status = <air>|<landing>|<landed>;
		public Position ::
			x : nat
			y : nat;
		public Directions ::
			x : int
			y : int;

	values
	-- TODO Define values here

	instance variables
		private speed : int;
		private pos : Position;
		private dir : Directions;
		private status : Status;
		private dest : Position;

	operations

		-- Construtor of the plane class
		public Plane : int * nat * nat * real * real * Status ==> Plane
			Plane(initial_speed, pos_x, pos_y, dir_x, dir_y, stat) == (
				speed := initial_speed;
				pos := mk_Position(pos_x, pos_y);
				-- If the dest equals the pos then it means the plane will move only due to direction and not to a specifc goal
				dest := mk_Position(pos_x, pos_y);
				dir := mk_Directions(dir_x, dir_y);
				status := stat;
			);

		-- Operation to set current speed of the plane
		public setSpeed : int ==> ()
			setSpeed(new_speed) == (
				speed := new_speed;
			);

		-- Operation to get current speed of the plane
		public getSpeed : () ==> int
			getSpeed() == (
				return speed;
			);

		-- Operation to set current position of the plane
		public setPosition : nat * nat ==> ()
			setPosition(initial_x, initial_y) == (
				pos := mk_Position(initial_x, initial_y);
			);
		-- pre: position must be inside map limits

		-- Operation to get current position of the plane
		public getPosition : () ==> Position
			getPosition() == (
				return pos;
			);

		-- Operation to set current directions of the plane
		public setDirections : real * real ==> ()
			setDirections(dir_x, dir_y) == (
				dir := mk_Directions(dir_x, dir_y);
			);
			

		-- Operation to get current directions of the plane
		public getDirections : () ==> Directions
			getDirections() == (
				return dir;
			);

		-- Operation to get current direction of the plane
		public getDirection : () ==> Direction
			getDirection() == (
				return calcDirSymbol(dir.x, dir.y);
			);

		-- Operation to set current status of the plane
		public setStatus : Status ==> ()
			setStatus(stat) == (
				status := stat;
			);

		-- Operation to get current status of the plane
		public getStatus : () ==> Status
			getStatus() == (
				return status;
			);

		-- Operation to set a destination to the plane
		public setDestination : nat * nat ==> ()
			setDestination(pos_x, pos_y) == (
				dest := mk_Position(pos_x, pos_y);
			);
		-- pre: destination must be inside map limits

		-- Operation to get a destination to the plane
		public getDestination : () ==> Position
			getDestination() == (
				return dest;
			);

		-- Operation to get the plane to move for this round
		public move : () ==> Position
			move() == (
				-- update direction
				dir.x := dest.x - pos.x;
				dir.y := dest.y - pos.y;
				
				if (dir = mk_Directions(0, 0))
				then
					return pos;

				-- unitary direction
				dir.x := dir.x / MATH`sqrt(dir.x * dir.x + dir.y * dir.y);
				dir.y := dir.y / MATH`sqrt(dir.x * dir.x + dir.y * dir.y);

				-- update position
				pos.x := pos.x + (dir.x * speed);
				pos.y := pos.y + (dir.y * speed);
				
				-- return the new position
				return pos;
			);
		-- post: position must be inside map limits

	functions

		-- Function to return the symbol of a given direction
		public calcDirSymbol : real * real -> Direction
			calcDirSymbol(dir_x, dir_y) == (
				if (dir_x = 0 and dir_y > 0)
					then <N>
				else if (dir_x > 0 and dir_y = 0)
					then <E>
				else if (dir_x = 0 and dir_y < 0)
					then <S>
				else if (dir_x < 0 and dir_y = 0)
					then <W>
				else if (MATH`tan(dir_x / dir_y) > 0 and MATH`tan(dir_x / dir_y) < 90)
					then <NE>
				else if (MATH`tan(dir_x / dir_y) > 90 and MATH`tan(dir_x / dir_y) < 180)
					then <NW>
				else if (MATH`tan(dir_x / dir_y) > 180 and MATH`tan(dir_x / dir_y) < 270)
					then <SW>
				else if (MATH`tan(dir_x / dir_y) > 270 and MATH`tan(dir_x / dir_y) < 360)
					then <SE>
				else <X>
			);
			-- Pre-condition: dir_x and dir_y can't be zero at same time
			-- pre (dir_x <> 0 and dir_y <> 0);
			-- Post-condition: dir.symbol can't be <X>
			-- post (dir.symbol <> <X>);

	traces
	-- TODO Define Combinatorial Test Traces here

end Plane